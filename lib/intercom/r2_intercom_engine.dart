// Copyright (c) 2025 RockRoad Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

import 'dart:async';
import 'package:flutter/material.dart';
import 'package:agora_rtc_engine/agora_rtc_engine.dart';
import 'package:permission_handler/permission_handler.dart';

import 'package:r2cyclingapp/connection/http/openapi/common_api.dart';
import 'package:r2cyclingapp/database/r2_storage.dart';

// customers' app id and token generated by Shengwang
const swAppId = "";
const swToken = "";

typedef IntercomCallback = void Function(int value);
typedef IntercomErrorHandler = void Function(
    String message, IntercomErrorKind kind);

enum IntercomErrorKind {
  permission,
  network,
  unauthorized,
  engine,
  token,
  unknown,
}

/* an interface and error primitive for intercom engine */
abstract class IntercomEngine {
  Future<void> initAgora();
  Future<void> pauseSpeak(bool mute);
  Future<void> stopIntercom();
}

/* 
 * R2IntercomEngine implements IntercomEngine
 * it is a singleton class
 * it is used to manage intercom engine
 * it is used to init agora engine
 * it is used to pause and stop intercom
 */
class R2IntercomEngine implements IntercomEngine {
  // Private constructor for singleton
  R2IntercomEngine._internal({
    required int groupID,
    required int userID,
    this.onLocalJoined,
    this.onMemberJoined,
    this.onMemberLeft,
    this.onMemberSpeaking,
    this.onError,
  })  : _groupID = groupID,
        _userID = userID;

  static IntercomEngine? _instance;
  static IntercomEngine Function({
    required int groupID,
    required int userID,
    IntercomCallback? onLocalJoined,
    IntercomCallback? onMemberJoined,
    IntercomCallback? onMemberLeft,
    IntercomCallback? onMemberSpeaking,
    IntercomErrorHandler? onError,
  }) _factory = ({
    required int groupID,
    required int userID,
    IntercomCallback? onLocalJoined,
    IntercomCallback? onMemberJoined,
    IntercomCallback? onMemberLeft,
    IntercomCallback? onMemberSpeaking,
    IntercomErrorHandler? onError,
  }) =>
      R2IntercomEngine._internal(
        groupID: groupID,
        userID: userID,
        onLocalJoined: onLocalJoined,
        onMemberJoined: onMemberJoined,
        onMemberLeft: onMemberLeft,
        onMemberSpeaking: onMemberSpeaking,
        onError: onError,
      );

  // Singleton factory method
  static IntercomEngine? getInstance({
    int? groupID,
    int? userID,
    IntercomCallback? onLocalJoined,
    IntercomCallback? onMemberJoined,
    IntercomCallback? onMemberLeft,
    IntercomCallback? onMemberSpeaking,
    IntercomErrorHandler? onError,
  }) {
    if (_instance == null) {
      if (groupID == null || userID == null) {
        return null;
      }
      _instance = _factory(
        groupID: groupID,
        userID: userID,
        onLocalJoined: onLocalJoined,
        onMemberJoined: onMemberJoined,
        onMemberLeft: onMemberLeft,
        onMemberSpeaking: onMemberSpeaking,
        onError: onError,
      );
    }
    return _instance!;
  }

  static void setFactory(
      IntercomEngine Function({
        required int groupID,
        required int userID,
        IntercomCallback? onLocalJoined,
        IntercomCallback? onMemberJoined,
        IntercomCallback? onMemberLeft,
        IntercomCallback? onMemberSpeaking,
        IntercomErrorHandler? onError,
      }) factory) {
    _factory = factory;
    _instance = null;
  }

  final int? _groupID;
  final int? _userID;
  final IntercomCallback? onLocalJoined;
  final IntercomCallback? onMemberJoined;
  final IntercomCallback? onMemberLeft;
  final IntercomCallback? onMemberSpeaking;
  final IntercomErrorHandler? onError;

  late RtcEngine _engine;
  String? _rtcAppId;
  String? _rtcToken;

  Future<void> _requestRTCToken() async {
    final r2token = await R2Storage.getToken();
    final api = CommonApi.defaultClient();
    Map<String, dynamic> resp;
    try {
      resp = await api.getVoiceToken(
        cyclingGroupId: '$_groupID',
        apiToken: r2token,
      );
    } catch (e) {
      onError?.call('Token request error: $e', IntercomErrorKind.network);
      return;
    }

    final bool result = (resp['success'] ?? false) == true;
    final int code = resp['code'] is int
        ? resp['code']
        : int.tryParse('${resp['code'] ?? 0}') ?? 0;
    if (result && code == 200) {
      final Map<String, dynamic> data =
          (resp['result'] ?? {}) as Map<String, dynamic>;
      _rtcAppId = data['appId'];
      _rtcToken = data['token'];
      debugPrint('_rtcAppId: $_rtcAppId');
      debugPrint('_rtcToken: $_rtcToken');
    } else {
      onError?.call(
          resp['message']?.toString() ?? 'Invalid token response',
          code == 401
              ? IntercomErrorKind.unauthorized
              : IntercomErrorKind.network);
    }
  }

  /*
   * initialize the Agora rtc engine developed by Shengwang
   */
  @override
  Future<void> initAgora() async {
    final status = await Permission.microphone.request();
    if (!status.isGranted) {
      onError?.call(
          'Microphone permission denied', IntercomErrorKind.permission);
      return;
    }

    // check if swAppId and swToken are provided, otherwise request from API
    if (swAppId.isNotEmpty && swToken.isNotEmpty) {
      _rtcAppId = swAppId;
      _rtcToken = swToken;
      debugPrint('Using hardcoded swAppId: $_rtcAppId');
      debugPrint('Using hardcoded swToken: $_rtcToken');
    } else {
      await _requestRTCToken();
    }

    if (_rtcAppId == null ||
        _rtcToken == null ||
        _rtcAppId!.isEmpty ||
        _rtcToken!.isEmpty) {
      onError?.call('RTC credentials missing', IntercomErrorKind.token);
      return;
    }

    // create and instance of rtc engine
    try {
      _engine = createAgoraRtcEngine();
      await _engine.initialize(RtcEngineContext(
        appId: _rtcAppId!,
        channelProfile: ChannelProfileType.channelProfileLiveBroadcasting,
      ));
    } catch (e) {
      onError?.call('Engine init error: $e', IntercomErrorKind.engine);
      return;
    }

    // register an event handler to handle the group action
    _engine.registerEventHandler(
      RtcEngineEventHandler(
          // the local user has joined group
          onJoinChannelSuccess: (RtcConnection connection, int elapsed) {
        debugPrint("local user ${connection.localUid} joined");
        onLocalJoined?.call(connection.localUid!);
      },
          // the remote member has joined group
          onUserJoined: (RtcConnection connection, int remoteUid, int elapsed) {
        debugPrint("$runtimeType: remote user $remoteUid joined");
        onMemberJoined?.call(remoteUid);
      },
          // the remote member has left group
          onUserOffline: (RtcConnection connection, int remoteUid,
              UserOfflineReasonType reason) {
        debugPrint("$runtimeType: remote user $remoteUid left channel");
        onMemberLeft?.call(remoteUid);
      }, onActiveSpeaker: (RtcConnection connection, int uid) {
        debugPrint("$runtimeType: current speaker $uid");
        onMemberSpeaking?.call(uid);
      }),
    );

    try {
      await _engine.joinChannelWithUserAccount(
        token: _rtcToken!,
        channelId: _groupID.toString(),
        userAccount: _userID.toString(),
        options: const ChannelMediaOptions(
            autoSubscribeAudio: true,
            publishMicrophoneTrack: true,
            clientRoleType: ClientRoleType.clientRoleBroadcaster),
      );
    } catch (e) {
      onError?.call('Join error: $e', IntercomErrorKind.engine);
      return;
    }

    // mute mic input initially
    _engine.muteLocalAudioStream(true);
  }

  /*
   *
   */
  @override
  Future<void> pauseSpeak(bool mute) async {
    try {
      _engine.muteLocalAudioStream(mute);
    } catch (e) {
      onError?.call('Mute error: $e', IntercomErrorKind.engine);
    }
  }

  /*
   * stop intercom
   */
  @override
  Future<void> stopIntercom() async {
    debugPrint('$runtimeType: stop intercom');
    try {
      await _engine.leaveChannel();
      await _engine.release();
    } catch (e) {
      onError?.call('Stop error: $e', IntercomErrorKind.engine);
    }
  }
}
